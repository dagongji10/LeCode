# -*- coding: utf-8 -*-
"""
Created on Tue Aug 20 17:21:36 2019

@author: Administrator
"""

'''
双指针法：
1、假设有0-5总共6个元素,我们先从最宽的两块板子h[0]/h[5]看起
2、h[0]/h[5]的面积应该是 较小的高度*5,假设较小的是h[0],那么它们的面积就是 h[0]*5
3、这个时候我们可以发现,与h[0]搭档的所有组合中面积最大就是 h[0]/h[5];因为,如果其它的搭档中h[0]是较小的高度,宽度肯定小于5;如果h[0]是较大的高度,那么用于计算面积的宽度、高度都小于h[0]/h[5]的组合
4、既然与h[0]搭档的所有组合的最大值已经找到了,那么就不需要h[0]了,让它往里走一步,我们开始计算h[1]/h[5]
5、同样的,如果h[1]是较小的高度,那么1-5之间能够与h[1]搭档的组合都会小于h[1]/h[5]的面积,而漏了的h[0]/h[1]在h[0]的搭档组合中已经做过比较了,它不可能比h[0]h[5]大
6、这样就又往里走一步,当然也是往较小h[1]这边走
7、这种往里走的规则,可以找到与较小高度板子搭档、且在区间内部的所有组合中面积最大的那个,至于在区间之外的组合,它总是存在于之前的组合搜索中(也完成了比较)

这种思想可以通过画一棵树来形象表示：
树的最上层表示最大区间的组合，它只有一种，就是(0,5)
接了下来是区间为4的组合：(0,4),(1,5)
依次画下来,然后会发现(0,5)大于其他的(0,j),(1,5)大于剩下的(1,j),注意这里的(0,1)跟(1,0)是一样的
按照往短边内收的原则依次走下来,就找到了最大的面积!
'''

def maxArea(height) -> int:
    calc_v = lambda x,y:abs(x - y) * min(height[x], height[y])
    
    l = 0
    r = len(height)-1
    max_v = 0
    while(l<r):
        max_v = max(max_v, calc_v(l, r))
        if height[l]<height[r]:
            l += 1
        else:
            r -= 1
            
    return max_v
