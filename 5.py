# -*- coding: utf-8 -*-
"""
Created on Wed Aug 14 10:22:24 2019

@author: Administrator
"""

'''
ManACher算法：
思想：
遍历每个字符，以字符为中心向两边延伸找到最长的回文串

假设：
当前字符位置为 i，之前 i-1 个字符位置的回文串长度(其实是1/2)存在数组len中

分析：
正常情况下，找位置 i 的回文串，只需要逐个判断 s[i-1]==s[i+1],s[i-2]==s[i+2],s[i-3]==s[i+3],..., 直到不相等则说明以该位置为中心的最长回文串找到
但考虑到一种特殊情况，位置 i 有一个短回文串，它包含于 i 之前的一个长回文串，如果将 i 关于长回文串的中心做对称就能找到位置 j，这个位置也会存在一个回文串并且它的长度我们是已经计算好了的
根据 i/j 位置的回文串有部分相同，可以利用 j 的回文串信息提前更新 i 的回文串长度，这样就不必从 i+1 开始判断了
具体来说，如果 j 回文串的左端在长回文串内部，那么 i 的起始判断位置就是 i+len(j)+1；否则的话，就从长回文串的最右端开始判断，因为 j 回文串与长回文串重叠的那部分也是回文的
'''

def longestPalindrome(s: str) -> str:
    if len(s)>1000:
        return None
    
    ss = '^#'+'#'.join([c for c in s])+'#&'
    
    l = [0]*len(ss)                             # 回文串长度（1/2）记录
    p0 = 0                                      # 最长回文串中心位置
    p = 0                                       # 最长回文串右端位置
    
    for i in range(1, len(ss)-1):
        if i<p:                                 # 如果在内部就更新回文串的长度信息
            j = 2*p0-i
            l[i] = min(p-i, l[j])
            
        while(ss[i-l[i]-1]==ss[i+l[i]+1]):      # 查找回文串
            l[i] += 1
            
        if l[i]>l[p0]:                          # 更新最长回文串
            p0 = i
            p = i+l[i]
    
    return ss[p0-l[p0]:p0+l[p0]].replace('#', '')
             
print(longestPalindrome('a1bcb2a'))